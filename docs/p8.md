# Interpolation Search (Wyszukiwanie interpolacyjne)

## Definicja

**Wyszukiwanie interpolacyjne** (interpolation search) to ulepszona wersja wyszukiwania binarnego dla **równomiernie rozłożonych danych**.  
Zamiast zawsze wybierać środkowy element, **szacuje pozycję** wartości na podstawie jej wielkości względem zakresu.

---

## Implementacja

```python
def search_interpolation(value, list):
    start = 0
    end = len(list) - 1
    found = False
    while start <= end and not found:
        if list[end] == list[start]:
            if list[start] == value:
                mid = start
                found = True
            else:
                break
        else:
            mid = int(start + (end - start) * (value - list[start]) / (list[end] - list[start]))
            if mid < start or mid > end:
                break
            if list[mid] == value:
                found = True
            else:
                if value < list[mid]:
                    end = mid - 1
                else:
                    start = mid + 1
    if found:
        return mid
    else:
        return None
```

### Jak to działa mentalnie

- lista musi być posortowana i równomiernie rozłożona
- szacujemy pozycję wartości na podstawie wzoru interpolacyjnego
- jeśli wartość jest mniejsza, szukamy w lewej części
- jeśli większa, szukamy w prawej części
- zawężamy przedział podobnie jak w binary search

### Wzór interpolacyjny

```
mid = start + (end - start) * (value - list[start]) / (list[end] - list[start])
```

Wzór zakłada równomierny rozkład wartości i szacuje pozycję proporcjonalnie do odległości wartości od granic przedziału.

### Właściwości

* czas: **O(log log n)** dla równomiernie rozłożonych danych
* najgorszy: **O(n)** dla nierównomiernie rozłożonych danych
* wymaga posortowanej listy z równomiernym rozkładem
* szybszy niż binary search dla równomiernie rozłożonych danych

### Kiedy używać

* lista jest posortowana i równomiernie rozłożona
* potrzebujesz bardzo szybkiego wyszukiwania
* dane są numeryczne z równomiernym rozkładem
* często lepszy niż binary search dla dużych, równomiernie rozłożonych zbiorów

### Kiedy NIE używać

* dane są nierównomiernie rozłożone
* dane są tekstowe (nie numeryczne)
* niepewność co do rozkładu danych

---

### Przykład wykonania krok po kroku

Wejściowa lista: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`, szukamy wartości: `5`

**Iteracja 1:**
- `start = 0`, `end = 9`
- `list[0] = 0`, `list[9] = 9`
- `mid = int(0 + (9 - 0) * (5 - 0) / (9 - 0)) = int(0 + 9 * 5 / 9) = int(5) = 5`
- `list[5] = 5 == 5?` → TAK → `found = True`
- Zwracamy `mid = 5`

Wynik: `5` (indeks wartości 5)

**Zauważ:** Dla równomiernie rozłożonych danych, interpolation search często znajduje wartość w pierwszej iteracji!

**Przykład 2: szukamy wartości 7**

Wejściowa lista: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`, szukamy wartości: `7`

**Iteracja 1:**
- `start = 0`, `end = 9`
- `mid = int(0 + (9 - 0) * (7 - 0) / (9 - 0)) = int(0 + 9 * 7 / 9) = int(7) = 7`
- `list[7] = 7 == 7?` → TAK → `found = True`
- Zwracamy `mid = 7`

Wynik: `7` (indeks wartości 7)

**Przykład 3: szukamy wartości, której nie ma**

Wejściowa lista: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`, szukamy wartości: `10`

**Iteracja 1:**
- `start = 0`, `end = 9`
- `mid = int(0 + (9 - 0) * (10 - 0) / (9 - 0)) = int(0 + 9 * 10 / 9) = int(10) = 10`
- `mid = 10 > end = 9?` → TAK → `break`
- Zwracamy `None`

Wynik: `None` (wartość poza zakresem)

**Przykład 4: nierównomiernie rozłożone dane**

Wejściowa lista: `[1, 2, 3, 100, 200, 300, 400, 500]`, szukamy wartości: `200`

**Iteracja 1:**
- `start = 0`, `end = 7`
- `list[0] = 1`, `list[7] = 500`
- `mid = int(0 + (7 - 0) * (200 - 1) / (500 - 1)) = int(0 + 7 * 199 / 499) = int(2.79) = 2`
- `list[2] = 3 == 200?` → NIE
- `200 > 3?` → TAK → `start = 2 + 1 = 3`

**Iteracja 2:**
- `start = 3`, `end = 7`
- `list[3] = 100`, `list[7] = 500`
- `mid = int(3 + (7 - 3) * (200 - 100) / (500 - 100)) = int(3 + 4 * 100 / 400) = int(4) = 4`
- `list[4] = 200 == 200?` → TAK → `found = True`
- Zwracamy `mid = 4`

Wynik: `4` (indeks wartości 200)

**Uwaga:** Dla nierównomiernie rozłożonych danych, interpolation search może być wolniejszy niż binary search.
