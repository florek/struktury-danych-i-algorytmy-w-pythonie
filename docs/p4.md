# Merge Sort

## Idea

Merge Sort to algorytm **dziel i zwyciężaj**.

> Kluczowa prawda:
> **Merge Sort nie sortuje list – on sortuje DWIE LISTY.**

Rekurencja służy tylko do dostarczenia danych.

---

## Implementacja

```python
def sort_merge(list):
    if len(list) <= 1:
        return list

    middle = len(list) // 2
    left = sort_merge(list[:middle])
    right = sort_merge(list[middle:])

    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### Co tu obserwować

- rekurencja NIC nie sortuje
- sortowanie zachodzi wyłącznie w scalaniu
- zawsze pracujesz na już posortowanych danych

### Właściwości

* czas: **O(n log n)**
* pamięć: **O(n)**
* stabilny
* przewidywalny

### Kiedy używać

* potrzebujesz stabilnego sortowania
* przewidywalność jest ważna
* masz wystarczająco dużo pamięci

### Przykład wykonania krok po kroku

Wejściowa lista: `[5, 2, 8, 1, 9]`

**Krok 1: Dzielenie (rekurencyjnie)**
```
[5, 2, 8, 1, 9]
  ↓
[5, 2]  [8, 1, 9]
  ↓        ↓
[5] [2]  [8] [1, 9]
            ↓
          [1] [9]
```

**Krok 2: Scalanie (od dołu do góry)**

Scalanie `[1]` i `[9]`:
- `1 < 9` → dodajemy 1 → `[1, 9]`

Scalanie `[8]` i `[1, 9]`:
- `8 < 1` → NIE → dodajemy 1 → `[1]`
- `8 < 9` → TAK → dodajemy 8 → `[1, 8]`
- Dodajemy resztę: `[1, 8, 9]`

Scalanie `[5]` i `[2]`:
- `5 < 2` → NIE → dodajemy 2 → `[2]`
- Dodajemy resztę: `[2, 5]`

Scalanie `[2, 5]` i `[1, 8, 9]`:
- `2 < 1` → NIE → dodajemy 1 → `[1]`
- `2 < 8` → TAK → dodajemy 2 → `[1, 2]`
- `5 < 8` → TAK → dodajemy 5 → `[1, 2, 5]`
- Dodajemy resztę: `[1, 2, 5, 8, 9]`

Wynik: `[1, 2, 5, 8, 9]`

Kluczowe: sortowanie zachodzi TYLKO podczas scalania dwóch już posortowanych list.
