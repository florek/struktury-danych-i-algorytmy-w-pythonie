# Quick Sort

## Idea

Quick Sort działa odwrotnie niż Merge Sort.

- nie scala
- ustawia **jeden element (pivot)**
- resztę zostawia rekurencji

---

## Implementacja

```python
def divide(arr, start, end):
    pivot = arr[end]
    i = start

    for j in range(start, end):
        if arr[j] <= pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1

    arr[i], arr[end] = arr[end], arr[i]
    return i


def quick_sort(arr, start, end):
    if start < end:
        p = divide(arr, start, end)
        quick_sort(arr, start, p - 1)
        quick_sort(arr, p + 1, end)
```

### Model mentalny

- pivot trafia na swoje miejsce
- elementy mniejsze są po lewej
- większe po prawej
- rekurencja robi resztę

### Właściwości

* średni czas: **O(n log n)**
* najgorszy: **O(n²)**
* in-place
* niestabilny

### Kiedy używać

* duże zbiory danych
* średnia wydajność jest ważniejsza niż najgorszy przypadek
* sortowanie in-place jest wymagane

### Przykład wykonania krok po kroku

Wejściowa lista: `[5, 2, 8, 1, 9]`, `start = 0`, `end = 4`

**Wywołanie 1: `quick_sort([5, 2, 8, 1, 9], 0, 4)`**
- `divide([5, 2, 8, 1, 9], 0, 4)`:
  - `pivot = 9` (ostatni element)
  - `i = 0`
  - `j = 0`: `5 <= 9` → TAK → swap `[5, 2, 8, 1, 9]` (bez zmian), `i = 1`
  - `j = 1`: `2 <= 9` → TAK → swap `[5, 2, 8, 1, 9]` (bez zmian), `i = 2`
  - `j = 2`: `8 <= 9` → TAK → swap `[5, 2, 8, 1, 9]` (bez zmian), `i = 3`
  - `j = 3`: `1 <= 9` → TAK → swap `[5, 2, 8, 1, 9]` (bez zmian), `i = 4`
  - Końcowy swap: `[5, 2, 8, 1, 9]` → pivot na pozycji 4
  - Zwraca `p = 4`

- `quick_sort([5, 2, 8, 1, 9], 0, 3)` - lewa część
- `quick_sort([5, 2, 8, 1, 9], 5, 4)` - prawa część (pusta, `start > end`)

**Wywołanie 2: `quick_sort([5, 2, 8, 1, 9], 0, 3)`**
- `divide([5, 2, 8, 1, 9], 0, 3)`:
  - `pivot = 1` (ostatni element w przedziale)
  - `i = 0`
  - `j = 0`: `5 <= 1` → NIE
  - `j = 1`: `2 <= 1` → NIE
  - `j = 2`: `8 <= 1` → NIE
  - Końcowy swap: `[1, 2, 8, 5, 9]` → pivot na pozycji 0
  - Zwraca `p = 0`

- `quick_sort([1, 2, 8, 5, 9], 0, -1)` - lewa część (pusta)
- `quick_sort([1, 2, 8, 5, 9], 1, 3)` - prawa część

**Wywołanie 3: `quick_sort([1, 2, 8, 5, 9], 1, 3)`**
- `divide([1, 2, 8, 5, 9], 1, 3)`:
  - `pivot = 5`
  - `i = 1`
  - `j = 1`: `2 <= 5` → TAK → swap `[1, 2, 8, 5, 9]` (bez zmian), `i = 2`
  - `j = 2`: `8 <= 5` → NIE
  - Końcowy swap: `[1, 2, 5, 8, 9]` → pivot na pozycji 2
  - Zwraca `p = 2`

- `quick_sort([1, 2, 5, 8, 9], 1, 1)` - lewa część (jeden element)
- `quick_sort([1, 2, 5, 8, 9], 3, 3)` - prawa część (jeden element)

**Wywołanie 4 i 5:** `start == end` → STOP (jeden element jest już posortowany)

Wynik: `[1, 2, 5, 8, 9]`

Kluczowe: pivot trafia na swoje miejsce, elementy mniejsze po lewej, większe po prawej.
