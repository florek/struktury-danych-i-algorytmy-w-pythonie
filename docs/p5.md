# Quick Sort

## Idea

Quick Sort działa odwrotnie niż Merge Sort.

- nie scala
- ustawia **jeden element (pivot)**
- resztę zostawia rekurencji

---

## Implementacja

```python
def divide(arr, start, end):
    pivot = arr[end]
    i = start

    for j in range(start, end):
        if arr[j] <= pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1

    arr[i], arr[end] = arr[end], arr[i]
    return i


def quick_sort(arr, start, end):
    if start < end:
        p = divide(arr, start, end)
        quick_sort(arr, start, p - 1)
        quick_sort(arr, p + 1, end)
```

### Model mentalny

- pivot trafia na swoje miejsce
- elementy mniejsze są po lewej
- większe po prawej
- rekurencja robi resztę

### Właściwości

* średni czas: **O(n log n)**
* najgorszy: **O(n²)**
* in-place
* niestabilny

### Kiedy używać

* duże zbiory danych
* średnia wydajność jest ważniejsza niż najgorszy przypadek
* sortowanie in-place jest wymagane
