# Selection Sort

Selection Sort polega na **wybieraniu minimum** z nieposortowanej części.

```python
def sort_selection(list):
    for run in range(len(list)):
        min_index = run
        for i in range(run + 1, len(list)):
            if list[i] < list[min_index]:
                min_index = i
        list[run], list[min_index] = list[min_index], list[run]
```

### Jak myśleć

- dzielisz listę na posortowaną i nieposortowaną
- zawsze szukasz minimum
- wykonujesz dokładnie jeden swap na iterację

### Właściwości

* czas: **O(n²)**
* niestabilny
* in-place
* mało swapów, dużo porównań

### Kiedy używać

* małe zbiory danych
* gdy swapy są kosztowne
* prostota implementacji jest ważniejsza niż wydajność

### Przykład wykonania krok po kroku

Wejściowa lista: `[5, 2, 8, 1, 9]`

**run = 0 (szukamy minimum od pozycji 0):**
- `min_index = 0` (wartość: 5)
- Porównanie: `2 < 5` → TAK → `min_index = 1`
- Porównanie: `8 < 2` → NIE
- Porównanie: `1 < 2` → TAK → `min_index = 3`
- Porównanie: `9 < 1` → NIE
- Swap `list[0]` z `list[3]`: `[1, 2, 8, 5, 9]`

**run = 1 (szukamy minimum od pozycji 1):**
- `min_index = 1` (wartość: 2)
- Porównanie: `8 < 2` → NIE
- Porównanie: `5 < 2` → NIE
- Porównanie: `9 < 2` → NIE
- Swap `list[1]` z `list[1]`: `[1, 2, 8, 5, 9]` (bez zmian)

**run = 2 (szukamy minimum od pozycji 2):**
- `min_index = 2` (wartość: 8)
- Porównanie: `5 < 8` → TAK → `min_index = 3`
- Porównanie: `9 < 5` → NIE
- Swap `list[2]` z `list[3]`: `[1, 2, 5, 8, 9]`

**run = 3 (szukamy minimum od pozycji 3):**
- `min_index = 3` (wartość: 8)
- Porównanie: `9 < 8` → NIE
- Swap `list[3]` z `list[3]`: `[1, 2, 5, 8, 9]` (bez zmian)

**run = 4 (szukamy minimum od pozycji 4):**
- `min_index = 4` (ostatni element)
- Swap `list[4]` z `list[4]`: `[1, 2, 5, 8, 9]` (bez zmian)

Wynik: `[1, 2, 5, 8, 9]`

Po każdej iteracji `run` elementy na pozycjach 0..run są posortowane.
