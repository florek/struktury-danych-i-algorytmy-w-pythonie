# Insertion Sort

Insertion Sort działa jak **sortowanie kart w ręce**.

```python
def sort_insert(list):
    for sort_border in range(1, len(list)):
        curr_idx = sort_border - 1
        value = list[curr_idx + 1]
        while curr_idx >= 0 and list[curr_idx] > value:
            list[curr_idx + 1] = list[curr_idx]
            curr_idx -= 1
        list[curr_idx + 1] = value
```

### Model mentalny

- lewa część listy jest zawsze posortowana
- jeden element jest „wstawiany" w dobre miejsce
- przesuwasz elementy w prawo, aż znajdziesz lukę

### Właściwości

* czas: **O(n²)**, najlepszy: **O(n)**
* stabilny
* in-place
* świetny dla małych lub prawie posortowanych danych

### Kiedy używać

* małe zbiory danych
* dane prawie posortowane
* potrzeba stabilnego sortowania in-place

### Przykład wykonania krok po kroku

Wejściowa lista: `[5, 2, 8, 1, 9]`

**sort_border = 1 (wstawiamy element na pozycji 1):**
- `value = 2`, `curr_idx = 0`
- `list[0] = 5 > 2` → TAK → przesuwamy: `[5, 5, 8, 1, 9]`, `curr_idx = -1`
- `curr_idx < 0` → STOP
- Wstawiamy `value`: `[2, 5, 8, 1, 9]`

**sort_border = 2 (wstawiamy element na pozycji 2):**
- `value = 8`, `curr_idx = 1`
- `list[1] = 5 > 8` → NIE → STOP
- Wstawiamy `value`: `[2, 5, 8, 1, 9]` (bez zmian)

**sort_border = 3 (wstawiamy element na pozycji 3):**
- `value = 1`, `curr_idx = 2`
- `list[2] = 8 > 1` → TAK → przesuwamy: `[2, 5, 8, 8, 9]`, `curr_idx = 1`
- `list[1] = 5 > 1` → TAK → przesuwamy: `[2, 5, 5, 8, 9]`, `curr_idx = 0`
- `list[0] = 2 > 1` → TAK → przesuwamy: `[2, 2, 5, 8, 9]`, `curr_idx = -1`
- `curr_idx < 0` → STOP
- Wstawiamy `value`: `[1, 2, 5, 8, 9]`

**sort_border = 4 (wstawiamy element na pozycji 4):**
- `value = 9`, `curr_idx = 3`
- `list[3] = 8 > 9` → NIE → STOP
- Wstawiamy `value`: `[1, 2, 5, 8, 9]` (bez zmian)

Wynik: `[1, 2, 5, 8, 9]`

Lewa część listy jest zawsze posortowana po każdej iteracji.
