# Quick Select (Szybka selekcja)

## Definicja

**Quick Select** to algorytm do znajdowania **k-tego najmniejszego elementu** w nieposortowanej tablicy bez konieczności sortowania całej tablicy. Jest to zmodyfikowana wersja Quick Sort, która wykorzystuje partycjonowanie, ale rekurencyjnie przetwarza tylko jedną część tablicy.

---

## Implementacja

```python
def quick_select(arr, k):
    if k < 1 or k > len(arr):
        return None
    return _quick_select(arr, 0, len(arr) - 1, k - 1)


def _partition(arr, left, right):
    pivot_idx = right
    pivot_value = arr[pivot_idx]
    store_idx = left
    for i in range(left, right):
        if arr[i] < pivot_value:
            arr[store_idx], arr[i] = arr[i], arr[store_idx]
            store_idx += 1
    arr[store_idx], arr[pivot_idx] = arr[pivot_idx], arr[store_idx]
    return store_idx


def _quick_select(arr, left, right, k):
    if left == right:
        return arr[left]
    pivot_idx = _partition(arr, left, right)
    if k == pivot_idx:
        return arr[k]
    elif k < pivot_idx:
        return _quick_select(arr, left, pivot_idx - 1, k)
    else:
        return _quick_select(arr, pivot_idx + 1, right, k)
```

### Jak to działa mentalnie

- wybieramy pivot (zwykle ostatni element)
- partycjonujemy tablicę: elementy mniejsze od pivota po lewej, większe po prawej
- sprawdzamy pozycję pivota po partycjonowaniu
- jeśli pivot jest na pozycji k, to jest to szukany element
- jeśli k jest mniejsze niż pozycja pivota, szukamy w lewej części
- jeśli k jest większe, szukamy w prawej części
- kontynuujemy rekurencyjnie tylko w odpowiedniej części

### Partycjonowanie (Lomuto partition scheme)

```
[7, 10, 4, 3, 20, 15]  pivot = 15 (ostatni element)
```

Kroki partycjonowania:
1. Przechodzimy przez elementy od left do right-1
2. Jeśli element < pivot, zamieniamy go z elementem na pozycji store_idx
3. Zwiększamy store_idx
4. Na końcu zamieniamy pivot z elementem na pozycji store_idx

### Właściwości

* czas średni: **O(n)** - liniowy!
* czas najgorszy: **O(n²)** - gdy pivot zawsze jest skrajnym elementem
* pamięć: **O(1)** - partycjonowanie w miejscu
* nie wymaga posortowanej tablicy
* modyfikuje oryginalną tablicę (można użyć kopii)

### Kiedy używać

* potrzebujesz k-tego najmniejszego/największego elementu
* nie chcesz sortować całej tablicy
* tablica jest duża, a potrzebujesz tylko jednego elementu
* mediana, percentyle, k-ty percentyl
* znajdowanie top-k elementów (w połączeniu z innymi technikami)

### Kiedy NIE używać

* potrzebujesz wielu k-tych elementów (lepiej posortować raz)
* potrzebujesz posortowanej tablicy (użyj Quick Sort)
* tablica jest bardzo mała (prostsze metody mogą być szybsze)
* potrzebujesz stabilności (Quick Select nie jest stabilny)

---

### Przykład wykonania krok po kroku

Wejściowa tablica: `[7, 10, 4, 3, 20, 15]`, szukamy 3-tego najmniejszego elementu (k=3)

**Krok 1: Wywołanie główne**
- `quick_select([7, 10, 4, 3, 20, 15], 3)`
- `k = 3`, więc szukamy elementu na pozycji `k-1 = 2` (0-indexed)

**Krok 2: Pierwsze partycjonowanie**
- `left = 0`, `right = 5`, `k = 2`
- `pivot = arr[5] = 15`
- Partycjonowanie:
  - `i=0`: `arr[0]=7 < 15` → zamiana z `arr[0]`, `store_idx=1`
  - `i=1`: `arr[1]=10 < 15` → zamiana z `arr[1]`, `store_idx=2`
  - `i=2`: `arr[2]=4 < 15` → zamiana z `arr[2]`, `store_idx=3`
  - `i=3`: `arr[3]=3 < 15` → zamiana z `arr[3]`, `store_idx=4`
  - `i=4`: `arr[4]=20 >= 15` → brak zamiany
  - Zamiana pivota: `arr[4]` ↔ `arr[5]`
- Tablica po partycjonowaniu: `[7, 10, 4, 3, 15, 20]`
- `pivot_idx = 4`
- `k = 2 < 4` → szukamy w lewej części

**Krok 3: Rekurencja w lewej części**
- `left = 0`, `right = 3`, `k = 2`
- `pivot = arr[3] = 3`
- Partycjonowanie:
  - `i=0`: `arr[0]=7 >= 3` → brak zamiany
  - `i=1`: `arr[1]=10 >= 3` → brak zamiany
  - `i=2`: `arr[2]=4 >= 3` → brak zamiany
  - Zamiana pivota: `arr[0]` ↔ `arr[3]` (pivot jest najmniejszy)
- Tablica: `[3, 10, 4, 7, 15, 20]`
- `pivot_idx = 0`
- `k = 2 > 0` → szukamy w prawej części

**Krok 4: Rekurencja w prawej części**
- `left = 1`, `right = 3`, `k = 2`
- `pivot = arr[3] = 7`
- Partycjonowanie:
  - `i=1`: `arr[1]=10 >= 7` → brak zamiany
  - `i=2`: `arr[2]=4 < 7` → zamiana z `arr[1]`, `store_idx=2`
  - Zamiana pivota: `arr[2]` ↔ `arr[3]`
- Tablica: `[3, 4, 7, 10, 15, 20]`
- `pivot_idx = 2`
- `k = 2 == 2` → znaleźliśmy! Zwracamy `arr[2] = 7`

**Wynik:** `7` (3-ci najmniejszy element)

**Zauważ:** Tablica nie jest w pełni posortowana, ale element na pozycji 2 jest na właściwym miejscu!

---

### Przykład 2: Mediana (k = n/2)

Wejściowa tablica: `[7, 10, 4, 3, 20, 15]`, szukamy mediany (k = 3 dla 6 elementów)

Algorytm działa podobnie jak w przykładzie 1, znajdując 3-ci najmniejszy element bez sortowania całej tablicy.

---

### Przykład 3: Najmniejszy element (k = 1)

Wejściowa tablica: `[7, 10, 4, 3, 20, 15]`, szukamy najmniejszego elementu (k = 1)

**Krok 1:** Partycjonowanie z `pivot = 15`
- Tablica: `[7, 10, 4, 3, 15, 20]`, `pivot_idx = 4`
- `k-1 = 0 < 4` → lewa część

**Krok 2:** Partycjonowanie z `pivot = 3`
- Tablica: `[3, 10, 4, 7, 15, 20]`, `pivot_idx = 0`
- `k-1 = 0 == 0` → znaleźliśmy! Zwracamy `3`

**Wynik:** `3` (najmniejszy element)

---

### Porównanie z innymi podejściami

**Quick Select vs Sortowanie:**
- Sortowanie: O(n log n) - sortuje całą tablicę
- Quick Select: O(n) średnio - znajduje tylko jeden element

**Quick Select vs Linear Search dla minimum:**
- Linear Search: O(n) - zawsze liniowy
- Quick Select: O(n) średnio, O(n²) najgorszy - może być wolniejszy dla prostych przypadków

**Kiedy Quick Select jest lepszy:**
- Szukasz k-tego elementu gdzie k jest w środku zakresu
- Tablica jest duża
- Nie potrzebujesz posortowanej tablicy
